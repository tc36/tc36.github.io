<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <!-- Prevent it from appearing huge on mobile, 
       keep user-scalable=no to disallow pinch-zoom. -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />

  <title>Discogs Master (Partial Rescales)</title>

  <style>
    /* 
       BASE: Previously everything was half (50%) from the "original." 
       We keep that as the foundation (7px base font).
       Then we'll selectively bump certain elements to 85%, 90%, 100%, or 80% as requested.
    */

    html, body {
      margin: 0; 
      padding: 0;
      width: 100%; 
      height: 100%;
      background: #121212;
      color: #ffffff;
      font-family: Arial, sans-serif;
      /* The “overall half scale” base from prior code: 7px */
      font-size: 7px; 
      overflow: hidden;
      user-select: none;
    }

    /* ========== CARD STACK ========== */
    #card-stack {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
    }
    .card {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: #1e1e1e;
      border: 1px solid #333;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      transition: transform 0.2s ease-out, opacity 0.2s ease-out;
      cursor: pointer;
      opacity: 1;
    }

    /* SQUARE IMAGE: half-scale version is fine */
    .square-image {
      width: 100%;
      aspect-ratio: 1 / 1;
      position: relative;
      overflow: hidden;
      background: #333;
      flex: 0 0 auto;
    }
    .square-image img {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      object-fit: cover;
    }

    /* ========== CARD FOOTER ========== */
    /* Foundation was 0.5rem padding, keep that. */
    .card-footer {
      position: relative;
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0.5rem;
      box-sizing: border-box;
      overflow-y: auto;
    }
    .card-title {
      font-size: 3.5rem; /* was 1.2rem in the half code => now 85% of original */
      font-weight: bold;
      margin: 0.4rem 0 0.2rem;
      text-align: center;
      color: #fff;
    }
    .card-artist {
      font-size: 3.0rem; /* was 0.9 => now 1.53 (85% of 1.8) */
      margin: 0.2rem 0 0.8rem;
      text-align: center;
      color: #ccc;
    }
    .card-format {
      font-size: 1.0rem; /* was 0.5 => 85% of 1 => 0.85 */
      font-style: italic;
      margin-bottom: 1.0rem;
      text-align: center;
      color: #aaa;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    /* track items => from 0.6 => 1.02 */
    .track-item {
      margin: 0.1rem 0;
      color: #bbb;
      font-size: 1.8rem; 
      break-inside: avoid;
    }
    .card-tracklist {
      width: 100%;
      max-width: 365px;
      margin: 0 0.5rem;
      text-align: left;
      column-count: 2;
      column-gap: 0.5rem;
    }

    /* "List View" button => from 50% => 100% 
       The half code had:
         font-size: 0.6rem, padding: 0.4rem 0.7rem
       We revert to the half-coded “full” version => let's do 1.2rem, 0.8rem 1.4rem
       so it matches the old "100% scale" from half. 
    */
    .view-toggle-btn {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 1rem; /* was 0.5 => revert to 1rem */
      font-size: 2.0rem; 
      padding: 0.8rem 1.4rem; 
      background: #444;
      color: #fff;
      border: 1px solid #666;
      border-radius: 4px;
      cursor: pointer;
    }
    .view-toggle-btn:hover {
      background: #555;
    }

    /* ========== LIST VIEW ========== */
    #list-view {
      display: none;
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: #121212;
      overflow: hidden;
    }

    /* 
       "Search bar from 50 => 100%" => 
       revert top bar from 1.5rem => 3rem
       revert #list-search height from 1rem => 2rem
    */
    #list-top-bar {
      position: relative;
      width: 100%;
      height: 5rem; /* was 1.5 => now back to 3 */
      background: ##121212;
      display: flex;
      align-items: center;
      padding: 0rem 5rem; /* was 0 0.5 => revert to 1rem */
      box-sizing: border-box;
    }
    /* The input is 16px so iOS won't zoom, no change needed there. 
       But revert the half-coded height from 1rem => 2rem.
    */
    #list-search {
      flex: 1 1 auto;
      height: 4rem; 
      background: #333;
      border: 1px solid #444;
      border-radius: 4px;
      color: #fff;
      font-size: 16px; /* keep for iOS no-zoom */
      outline: none;
      padding: 0rem 5rem;
    }
    #list-search::placeholder {
      color: #888;
    }

    /* 
       "Scale each item row from 50 => 80%" 
       Original row had 1.5rem => half => 0.75 => now 80% => 1.2 
       Original thumb 160 => half => 80 => now 80% => 128
       Original .list-artist => 1.2 => half => 0.6 => now 0.96
       Original .list-album-format => 1 => half => 0.5 => now 0.8 
    */
    #list-content {
      position: absolute;
      top: 5rem; 
      left: 0;
      right: 60px; 
      bottom: 0;
      overflow-y: auto;
      box-sizing: border-box;
      padding: 1rem;
    }
    .list-item {
      display: flex;
      align-items: center;
      /* from 0.75 => 1.2 */
      padding: 1.2rem; 
      border-bottom: 1px solid #333;
      cursor: pointer;
    }
    .list-item:hover {
      background: #1e1e1e;
    }
    /* from 80 => 128 */
    .list-thumb {
      width: 128px;
      height: 128px;
      margin-right: 1.2rem; 
      background: #333;
      flex-shrink: 0;
      position: relative;
    }
    .list-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .list-info {
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    /* from 0.6 => 0.96 */
    .list-artist {
      font-size: 2.2rem; 
      color: #ccc;
      line-height: 1.2;
      margin-bottom: 0.3rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 80vw;
    }
    /* from 0.5 => 0.8 */
    .list-album-format {
      font-size: 1.7rem; 
      color: #aaa;
      line-height: 1.2;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 80vw;
    }

    /* "Keep the button filter exactly the size it is" => no changes to .letter-bar-btn. 
       So we keep the half-coded version: 
       width: 50px => 25, etc. We do not revert. We'll just keep it as is.
       Actually from our half code, we had 30 wide bar => 25 w/h? 
       We'll just keep it. 
       (No changes => see instructions.)
       So we do NOT change .letter-bar-btn below 
       because user said "keep exactly the size it is."
    */
    #list-letter-bar {
      position: absolute;
      top: 5rem;
      right: 0;
      width: 33px; 
      bottom: 0;
      background: #121212;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-around;
      padding: 0.25rem 0; 
      box-sizing: border-box;
    }
    .letter-bar-btn {
      background: none;
      border: 1px solid #444;
      border-radius: 2px;
      color: #ccc;
      font-size: 1.3rem;
      width: 25px;
      height: 25px;
      cursor: pointer;
      text-align: center;
      line-height: 23px;
      margin: 0.125rem 0;
    }
    .letter-bar-btn:hover {
      color: #fff;
      border-color: #fff;
    }

    /* ========== INFO OVERLAY (CARD) ========== */
    /* "Scale the additional info from 50 => 100%" => revert to the original half-coded "full." 
       Let's do double of the half: if we had 0.5rem => 1rem, etc. 
       So, was #info-content * => 0.5rem => now 1rem, 
          h2 => 0.7 => 1.4, 
          h3 => 0.6 => 1.2, 
          margin => double. 
    */
    #info-overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; 
      height: 100%;
      background: rgba(0,0,0,0.8);
      color: #fff;
      z-index: 100;
      display: none;
      opacity: 0;
      transition: opacity 0.3s ease;
      padding: 4rem 4rem; 
      box-sizing: border-box;
      overflow-y: auto;
    }
    #info-overlay.visible {
      display: block;
      opacity: 1;
    }
    /* revert from 0.5 => 1.0 */
    #info-content * {
      font-size: 2.0rem;
      line-height: 1.4;
    }
    /* from 0.7 => 1.4 */
    #info-content h2 {
      margin-top: 0;
      margin-bottom: 0.5rem;
      font-size: 4rem;
    }
    /* from 0.6 => 1.2 */
    #info-content h3 {
      margin-top: 0;
      margin-bottom: 4rem;
      color: #ccc;
      font-size: 3rem;
    }
    /* margin-top from 0.4 => 0.8, margin-bottom from 0.2 => 0.4 */
    .extra-label {
      font-weight: bold;
      margin-top: 0.8rem;
      color: #ddd;
    }
    .extra-value {
      margin-bottom: 0.4rem;
      color: #ccc;
    }

    /* ========== LETTER MENU OVERLAY (CARD) ========== */
    /* from 50 => 90%. The original was: big-button => 1.4rem => half => 0.7 => now 1.26 (which is 0.9 * 1.4)
       widths from 70 => 126, heights from 30 => 54 
       letter-btn => from 0.7rem => 1.26rem, from 30 => 54 
    */
    #letter-overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; 
      height: 100%;
      background: rgba(0,0,0,0.8);
      color: #fff;
      z-index: 150;
      display: none;
      opacity: 0;
      transition: opacity 0.3s ease;
      padding: 0.5rem;
      box-sizing: border-box;
    }
    #letter-overlay.visible {
      display: block;
      opacity: 1;
    }
    #letter-grid {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100%;
      gap: 0.5rem;
    }
    /* big-button from 0.7 => 1.26 => width 70 => 126 => height 30 => 54 => line-height ~52? */
    .big-button {
      background: none;
      border: 2px solid #444; 
      border-radius: 3px; 
      color: #ccc;
      font-size: 3.5rem; 
      width: 150px; 
      height: 54px;
      cursor: pointer;
      text-align: center;
      line-height: 52px; 
    }
    .big-button:hover {
      color: #fff;
      border-color: #fff;
    }
    .letters-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.3rem;
    }
    /* letter-btn => from 0.7 => 1.26 => from 30 => 54 */
    .letter-btn {
      background: none;
      border: 2px solid #444;
      border-radius: 2px;
      color: #ccc;
      font-size: 2rem;
      width: 54px;
      height: 54px;
      cursor: pointer;
    }
    .letter-btn:hover {
      color: #fff;
      border-color: #fff;
    }
  </style>
</head>
<body>

<div id="card-stack"></div>

<div id="list-view" style="display:none;">
  <div id="list-top-bar">
    <input type="text" id="list-search" placeholder="Search (artist, album, format, genre)..." />
  </div>
  <div id="list-content"></div>
  <div id="list-letter-bar"></div>
</div>

<div id="info-overlay">
  <div id="info-content"></div>
</div>

<div id="letter-overlay">
  <div id="letter-grid">
    <button class="big-button" id="allBtn">ALL</button>
    <div class="letters-container" id="lettersContainer"></div>
    <button class="big-button" id="randomBtn">RANDOM</button>
  </div>
</div>

<script>
/***********************
 * SPOTIFY
 ***********************/
// ----- SPOTIFY CONFIGURATION -----
// Replace these with your actual Spotify API credentials.
const SPOTIFY_CLIENT_ID = "a16e10b537b148c4bb702342e1e9e8ab";
const SPOTIFY_CLIENT_SECRET = "31330552b24d457b8293843bace31653";

// We’ll cache the token once we get it.
let spotifyAccessToken = null;

// Get a Spotify access token using the Client Credentials Flow.
async function getSpotifyAccessToken() {
  if (spotifyAccessToken) return spotifyAccessToken;
  const result = await fetch("https://accounts.spotify.com/api/token", {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      "Authorization": "Basic " + btoa(SPOTIFY_CLIENT_ID + ":" + SPOTIFY_CLIENT_SECRET)
    },
    body: "grant_type=client_credentials"
  });
  const data = await result.json();
  spotifyAccessToken = data.access_token;
  return spotifyAccessToken;
}

// Search for an album on Spotify using the artist and album name.
async function searchSpotifyAlbum(artist, album) {
  const token = await getSpotifyAccessToken();
  const query = encodeURIComponent(artist + " " + album);
  const url = `https://api.spotify.com/v1/search?q=${query}&type=album&limit=1`;
  const response = await fetch(url, {
    headers: { "Authorization": "Bearer " + token }
  });
  const data = await response.json();
  if (data.albums && data.albums.items && data.albums.items.length > 0) {
    return data.albums.items[0].id; // Return the album ID
  }
  return null;
}

// Embed the Spotify player into a specified container.
// This function creates an iframe that fills the container's width.
async function embedSpotifyPlayerInContainer(container, artist, album) {
  try {
    const albumId = await searchSpotifyAlbum(artist, album);
    if (albumId) {
      const iframe = document.createElement("iframe");
      iframe.style.width = "100%";         // Full width of container
      iframe.style.height = "100px";         // Adjust height as needed
      iframe.src = `https://open.spotify.com/embed/album/${albumId}`;
      iframe.frameBorder = "0";
      iframe.allow = "encrypted-media";
      container.appendChild(iframe);
    } else {
      const msg = document.createElement("div");
      msg.textContent = "Spotify album not found.";
      msg.style.color = "#ccc";
      container.appendChild(msg);
    }
  } catch (error) {
    console.error("Error embedding Spotify player:", error);
  }
}

/***********************
 * CONFIG & GLOBALS
 ***********************/
const DISCOGS_TOKEN = "VNkatCCKeYpfYiFTEegtKYWWQaRzGMnuaySSMFqi";
const DISCOGS_USERNAME = "Taylors-Collection";
const PER_PAGE = 100;
const BASE_API_URL = "https://api.discogs.com/users/" + DISCOGS_USERNAME +
                     "/collection/folders/0/releases?per_page=" + PER_PAGE;

let allReleases = [];
let displayedReleases = [];
let detailsCache = {};

let currentIndex = 0;
let currentView = "card";

let listSearchText = "";

const cardStack = document.getElementById("card-stack");
const listView = document.getElementById("list-view");
const listSearch = document.getElementById("list-search");
const listContent = document.getElementById("list-content");
const listLetterBar = document.getElementById("list-letter-bar");

const infoOverlay = document.getElementById("info-overlay");
const infoContent = document.getElementById("info-content");
const letterOverlay = document.getElementById("letter-overlay");

const allBtn = document.getElementById("allBtn");
const randomBtn = document.getElementById("randomBtn");
const lettersContainer = document.getElementById("lettersContainer");

/* We'll guess each list row is 200px originally => half => 100, 
   user wants 80% => 160 => but we ended up at 128 for thumbnail, 
   1.2rem padding, so let's keep a single reference. We'll do 100 for offset. */
const LIST_ITEM_HEIGHT = 100;

const HORIZONTAL_THRESHOLD = 80;
const VERTICAL_THRESHOLD = 80;

function scrubArtistName(name) {
  return name.replace(/\(\d+\)/g, "").trim();
}

function scrubTrackTitle(title) {
  // Remove trailing whitespace first.
  title = title.trim();
  
  // Find the position of the last '(' in the title.
  const lastParenIndex = title.lastIndexOf('(');
  
  // If no parenthesis is found, return the title as-is.
  if (lastParenIndex === -1) {
    return title;
  }
  
  // Extract the substring starting at the last '('.
  const candidate = title.substring(lastParenIndex);
  
  // Use a regex to check if the candidate is a time format.
  // This regex matches an opening parenthesis, one or two digits,
  // a colon, exactly two digits, and a closing parenthesis.
  const timePattern = /^\(\d{1,2}:\d{2}\)$/;
  
  if (timePattern.test(candidate)) {
    // If it matches, remove that part of the title.
    return title.substring(0, lastParenIndex).trim();
  }
  
  // Otherwise, return the title unmodified.
  return title;
}

/***********************
 * INIT
 ***********************/
(async function init(){
  try {
    let data = await fetchEntireCollection();
    data.forEach(release => {
      if (release.basic_information && release.basic_information.artists) {
        release.basic_information.artists = release.basic_information.artists.map(artist => {
          return { ...artist, name: scrubArtistName(artist.name) };
        });
      }
    });
    data = sortByArtistName(data);
    allReleases = data;
    displayedReleases = allReleases.slice();

    buildCardLetterOverlay();
    buildListLetterBar();
    listSearch.addEventListener("input", onListSearch);

    renderCards();
  } catch(err){
    console.error("Init error:", err);
    let msg= document.createElement("div");
    msg.style.color="#ccc";
    msg.style.position="absolute";
    msg.style.top="50%";
    msg.style.left="50%";
    msg.style.transform="translate(-50%,-50%)";
    msg.textContent="Error loading. Check console.";
    cardStack.appendChild(msg);
  }
})();

/***********************
 * FETCH & SORT
 ***********************/
async function fetchEntireCollection(){
  let nextUrl = BASE_API_URL;
  let combined = [];
  while(nextUrl){
    let resp = await fetch(nextUrl,{
      headers:{
        "User-Agent":"DiscogsHalfScalePartialAdjust/1.0",
        "Authorization":"Discogs token="+ DISCOGS_TOKEN
      }
    });
    if(!resp.ok) throw new Error("Fetch error "+resp.status);
    let data = await resp.json();
    combined = combined.concat(data.releases||[]);
    if(data.pagination && data.pagination.urls && data.pagination.urls.next){
      nextUrl = data.pagination.urls.next;
    } else {
      nextUrl = null;
    }
  }
  return combined;
}
function sortByArtistName(arr){
  return arr.sort((a,b)=>{
    let an=(a.basic_information.artists[0]?.name||"").toLowerCase();
    let bn=(b.basic_information.artists[0]?.name||"").toLowerCase();
    return an.localeCompare(bn);
  });
}

/***********************
 * CARD LETTER OVERLAY
 ***********************/
function buildCardLetterOverlay(){
  allBtn.addEventListener("click",()=>{
    displayedReleases= allReleases.slice();
    currentIndex=0;
    hideLetterOverlay();
    renderCards();
  });
  randomBtn.addEventListener("click",()=>{
    let randIdx= Math.floor(Math.random()* allReleases.length);
    displayedReleases= allReleases.slice();
    currentIndex= randIdx;
    hideLetterOverlay();
    renderCards();
  });
  lettersContainer.innerHTML="";

  let symBtn= createCardLetterBtn("#",()=>{
    let idx= allReleases.findIndex(r=>{
      let nm=(r.basic_information.artists[0]?.name||"").toLowerCase();
      let first=nm.charAt(0);
      return first<'a'|| first>'z';
    });
    if(idx>=0){
      displayedReleases= allReleases.slice();
      currentIndex= idx;
    }
    hideLetterOverlay();
    renderCards();
  });
  lettersContainer.appendChild(symBtn);

  "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("").forEach(letter=>{
    let btn= createCardLetterBtn(letter,()=>{
      let low= letter.toLowerCase();
      let idx= allReleases.findIndex(r=>{
        let nm=(r.basic_information.artists[0]?.name||"").toLowerCase();
        return nm.startsWith(low);
      });
      if(idx>=0){
        displayedReleases= allReleases.slice();
        currentIndex= idx;
      }
      hideLetterOverlay();
      renderCards();
    });
    lettersContainer.appendChild(btn);
  });

  letterOverlay.addEventListener("touchstart", overlayTouchStart,{passive:false});
  letterOverlay.addEventListener("touchmove", overlayTouchMove,{passive:false});
  letterOverlay.addEventListener("touchend", overlayTouchEnd,{passive:false});
}
function createCardLetterBtn(txt, onClick){
  let b= document.createElement("button");
  b.className="letter-btn";
  b.textContent= txt;
  b.addEventListener("click", onClick);
  return b;
}
function showLetterOverlay(){
  letterOverlay.classList.add("visible");
}
function hideLetterOverlay(){
  letterOverlay.classList.remove("visible");
  setTimeout(()=>{
    if(!letterOverlay.classList.contains("visible")){
      letterOverlay.style.display="none";
      letterOverlay.offsetHeight;
      letterOverlay.style.display="";
    }
  },300);
}
let overlayStartY=0, overlayDiffY=0, overlayDragging=false;
function overlayTouchStart(e){
  let t=e.changedTouches[0];
  overlayStartY= t.clientY;
  overlayDiffY=0;
  overlayDragging=false;
}
function overlayTouchMove(e){
  let t=e.changedTouches[0];
  overlayDiffY= t.clientY- overlayStartY;
  if(Math.abs(overlayDiffY)>10) overlayDragging=true;
  e.preventDefault();
}
function overlayTouchEnd(e){
  if(!overlayDragging) return;
  if(overlayDiffY< -VERTICAL_THRESHOLD){
    hideLetterOverlay();
  }
}

/***********************
 * LIST VIEW LETTER BAR => jump => center
 ***********************/
// NEW PLUG‐AND‐PLAY SNIPPET FOR LIST VIEW LETTER BAR JUMP

function buildListLetterBar() {
  // Clear the letter bar container.
  listLetterBar.innerHTML = "";
  // Define the letters to show – "ALL" and "#" plus A–Z.
  const letters = ["ALL", "#", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
  
  letters.forEach(letter => {
    const btn = document.createElement("button");
    btn.className = "letter-bar-btn";
    btn.textContent = letter;
    btn.addEventListener("click", () => {
      // Clear any search filter so the full list is displayed.
      listSearch.value = "";
      listSearchText = "";
      // Rebuild the list with the full, unfiltered set.
      buildListItems(allReleases);
      
      // Determine the index of the first item whose artist starts with the chosen letter.
      let idx;
      if (letter === "ALL") {
        idx = 0;
      } else if (letter === "#") {
        // For "#", choose the first artist whose first character is not A–Z.
        idx = allReleases.findIndex(r => {
          const nm = (r.basic_information.artists[0]?.name || "").toUpperCase();
          return nm.length === 0 || nm[0] < "A" || nm[0] > "Z";
        });
      } else {
        idx = allReleases.findIndex(r => {
          const nm = (r.basic_information.artists[0]?.name || "").toUpperCase();
          return nm.charAt(0) === letter;
        });
      }
      // If an index is found, delay briefly to ensure the list is rendered, then center that item.
      if (idx >= 0) {
        setTimeout(() => {
          centerListItemByDOM(idx);
        }, 100);
      }
    });
    listLetterBar.appendChild(btn);
  });
}

// This new function uses the actual DOM position of the target list item
// to scroll it so that its center aligns with the middle of the list content.
function centerListItemByDOM(index) {
  const items = listContent.children;
  if (index < 0 || index >= items.length) return;
  const targetEl = items[index];
  // Calculate the center of the target element relative to its container.
  const targetCenter = targetEl.offsetTop + targetEl.offsetHeight / 2;
  const containerCenter = listContent.clientHeight / 2;
  listContent.scrollTop = targetCenter - containerCenter;
}


/***********************
 * LIST SEARCH
 ***********************/
function onListSearch(){
  listSearchText= listSearch.value.trim().toLowerCase();
  if(!listSearchText){
    buildListItems(allReleases);
  } else {
    let filtered= allReleases.filter(r=>{
      let info= r.basic_information;
      let art= info.artists.map(a=>a.name).join(", ").toLowerCase();
      let alb= info.title.toLowerCase();

      let fm="";
      if(info.formats && info.formats.length>0){
        fm= info.formats.map(f=>{
          if(f.descriptions && f.descriptions.length>0){
            return f.descriptions.join(", ");
          } else if(f.name) return f.name;
          else return "";
        }).filter(x=>x).join(" / ");
      }
      fm= fm.toLowerCase();

      let gStr="";
      if(info.genres) gStr+= info.genres.join(" ");
      if(info.styles) gStr+= " "+ info.styles.join(" ");
      gStr=gStr.toLowerCase();

      return(
        art.includes(listSearchText)||
        alb.includes(listSearchText)||
        fm.includes(listSearchText)||
        gStr.includes(listSearchText)
      );
    });
    buildListItems(filtered);
  }
}

/***********************
 * BUILD LIST
 ***********************/
function buildListItems(arr){
  listContent.innerHTML="";
  if(arr.length===0){
    let msg= document.createElement("div");
    msg.style.color="#ccc";
    msg.style.position="absolute";
    msg.style.top="50%";
    msg.style.left="50%";
    msg.style.transform="translate(-50%,-50%)";
    msg.textContent="No records found. Try a different search or letter.";
    listContent.appendChild(msg);
    return;
  }
  arr.forEach((rItem,i)=>{
    let row= createListRow(rItem,i);
    listContent.appendChild(row);
  });
}
function createListRow(rItem, idx){
  let info= rItem.basic_information;
  let row= document.createElement("div");
  row.className="list-item";

  let thumb= document.createElement("div");
  thumb.className="list-thumb";
  let im= document.createElement("img");
  im.src= info.cover_image;
  im.alt= info.title;
  thumb.appendChild(im);

  let textDiv= document.createElement("div");
  textDiv.className="list-info";

  let artistName= info.artists.map(a=>a.name).join(", ");
  let artistDiv= document.createElement("div");
  artistDiv.className="list-artist";
  artistDiv.textContent= artistName;

  let albumFmtDiv= document.createElement("div");
  albumFmtDiv.className="list-album-format";
  let fm="";
  if(info.formats && info.formats.length>0){
    fm= info.formats.map(f=>{
      if(f.descriptions && f.descriptions.length>0){
        return f.descriptions.join(", ");
      } else if(f.name) return f.name;
      else return "";
    }).filter(x=>x).join(" / ");
  }
  albumFmtDiv.textContent= info.title+" — "+ fm;

  textDiv.appendChild(artistDiv);
  textDiv.appendChild(albumFmtDiv);

  row.appendChild(thumb);
  row.appendChild(textDiv);

  row.addEventListener("click",()=>{
    let absoluteIndex= allReleases.indexOf(rItem);
    if(absoluteIndex<0) absoluteIndex=0;
    displayedReleases= allReleases.slice();
    currentIndex= absoluteIndex;
    renderCards();
  });
  return row;
}

/***********************
 * SWITCHING VIEWS
 ***********************/
function showListView(){
  currentView="list";
  cardStack.style.display="none";
  listView.style.display="block";
  if(listSearchText){
    onListSearch();
  } else {
    buildListItems(allReleases);
  }
}
function hideListView(){
  listView.style.display="none";
}

/***********************
 * RENDER CARDS
 ***********************/
function renderCards(){
  currentView="card";
  hideListView();
  cardStack.style.display="block";
  cardStack.innerHTML="";

  if(displayedReleases.length===0){
    let msg= document.createElement("div");
    msg.style.color="#ccc";
    msg.style.position="absolute";
    msg.style.top="50%";
    msg.style.left="50%";
    msg.style.transform="translate(-50%,-50%)";
    msg.textContent="No records found. Swipe down to open letter menu.";
    cardStack.appendChild(msg);
    return;
  }
  if(currentIndex>= displayedReleases.length) currentIndex= displayedReleases.length-1;
  if(currentIndex<0) currentIndex=0;

  let item= displayedReleases[currentIndex];
  let card= createCardElement(item);
  cardStack.appendChild(card);
}

/***********************
 * CREATE A SINGLE CARD
 ***********************/
let userIsDragging=false; /* define up here for clarity */
function createCardElement(rItem){
  let info= rItem.basic_information;
  let c= document.createElement("div");
  c.className="card";

  let sq= document.createElement("div");
  sq.className="square-image";
  let im= document.createElement("img");
  im.src= info.cover_image;
  im.alt= info.title;
  sq.appendChild(im);

  let foot= document.createElement("div");
  foot.className="card-footer";

  let titleEl= document.createElement("div");
  titleEl.className="card-title";
  titleEl.textContent= info.title;

  let artEl= document.createElement("div");
  artEl.className="card-artist";
  let artistStr= info.artists.map(a=>a.name).join(", ");
  artEl.textContent= artistStr;

  let formatEl= document.createElement("div");
  formatEl.className="card-format";
  let fm="";
  if(info.formats && info.formats.length>0){
    fm= info.formats.map(f=>{
      if(f.descriptions && f.descriptions.length>0){
        return f.descriptions.join(", ");
      } else if(f.name) return f.name;
      else return "";
    }).filter(x=>x).join(" / ");
  }
  formatEl.textContent= fm;

  let trackDiv= document.createElement("div");
  trackDiv.className="card-tracklist";
  fillTracklistIfNeeded(rItem, trackDiv);

  let lvBtn= document.createElement("button");
  lvBtn.className="view-toggle-btn";
  lvBtn.textContent="List View";
  lvBtn.addEventListener("click",(ev)=>{
    ev.stopPropagation();
    showListView();
  });

  foot.appendChild(titleEl);
  foot.appendChild(artEl);
  foot.appendChild(formatEl);
  foot.appendChild(trackDiv);
  foot.appendChild(lvBtn);

  c.appendChild(sq);
  c.appendChild(foot);

  c.addEventListener("click",(ev)=>{
    if(!userIsDragging){
      ev.stopPropagation();
      showInfoOverlay(rItem);
    }
  }, {passive:false});

  addSwipeHandlers(c);
  return c;
}

/***********************
 * FILL TRACKLIST
 ***********************/
async function fillTracklistIfNeeded(rItem, container){
  let rid= rItem.basic_information.id;
  if(detailsCache[rid]){
    fillTracklistSection(container, detailsCache[rid]);
  } else {
    let url= "https://api.discogs.com/releases/"+rid;
    try{
      let resp= await fetch(url,{
        headers:{
          "User-Agent":"DiscogsHalfScalePartialAdjust/1.0",
          "Authorization":"Discogs token="+ DISCOGS_TOKEN
        }
      });
      if(!resp.ok) throw new Error("Tracklist fetch error "+resp.status);
      let data= await resp.json();
      detailsCache[rid]= data;
      fillTracklistSection(container, data);
    } catch(err){
      console.error("Tracklist fetch err:", err);
      container.innerHTML="<p style='color:#bbb;'>Tracklist unavailable.</p>";
    }
  }
}

function fillTracklistSection(container, releaseData) {
  container.innerHTML = "";
  if (releaseData.tracklist && releaseData.tracklist.length > 0) {
    releaseData.tracklist.forEach(t => {
      let div = document.createElement("div");
      div.className = "track-item";
      
      // Build the display text using the track position and scrubbed title.
      let txt = t.position + " - " + scrubTrackTitle(t.title);
      
      div.textContent = txt;
      container.appendChild(div);
    });
  } else {
    container.innerHTML = "<p style='color:#bbb;'>No tracklist found.</p>";
  }
}

/***********************
 * SWIPE LOGIC (CARD)
 ***********************/
let startX=0, startY=0;
let currentTranslateX=0, currentTranslateY=0;

function addSwipeHandlers(el){
  el.addEventListener("touchstart", onTouchStart,{passive:false});
  el.addEventListener("touchmove", onTouchMove,{passive:false});
  el.addEventListener("touchend", onTouchEnd,{passive:false});

  function onTouchStart(e){
    if(infoOverlay.classList.contains("visible")|| letterOverlay.classList.contains("visible")) return;
    let t=e.changedTouches[0];
    startX= t.clientX;
    startY= t.clientY;
    userIsDragging=false;
    currentTranslateX=0; 
    currentTranslateY=0;
    el.style.transition="none";
  }
  function onTouchMove(e){
    if(infoOverlay.classList.contains("visible")|| letterOverlay.classList.contains("visible")) return;
    let t=e.changedTouches[0];
    let diffX= t.clientX - startX;
    let diffY= t.clientY - startY;
    let absX= Math.abs(diffX);
    let absY= Math.abs(diffY);

    if(absX>10|| absY>10) userIsDragging=true;

    if(absY>absX){
      currentTranslateY= diffY;
      el.style.transform=`translateY(${diffY*0.1}px)`;
      e.preventDefault();
    } else {
      currentTranslateX= diffX;
      let ratio= Math.min(absX/HORIZONTAL_THRESHOLD,1);
      let newOpacity= 1- (0.2* ratio);
      el.style.opacity= newOpacity;
      el.style.transform=`translateX(${diffX}px)`;
      e.preventDefault();
    }
  }
  function onTouchEnd(e){
    if(!userIsDragging){
      resetCardStyle(el);
      return;
    }
    let absX= Math.abs(currentTranslateX);
    let absY= Math.abs(currentTranslateY);

    if(absY> absX){
      if(currentTranslateY> VERTICAL_THRESHOLD){
        showLetterOverlay();
      } else if(currentTranslateY< -VERTICAL_THRESHOLD){
        if(letterOverlay.classList.contains("visible")){
          hideLetterOverlay();
        } else {
          resetCardStyle(el);
        }
      } else {
        resetCardStyle(el);
      }
    } else {
      if(absX>HORIZONTAL_THRESHOLD){
        if(currentTranslateX<0) currentIndex++;
        else currentIndex--;
        swipeCardOff(el, (currentTranslateX<0? -1:1));
      } else {
        resetCardStyle(el);
      }
    }
  }
  function swipeCardOff(elem, dir){
    elem.style.transition="transform 0.5s ease-out, opacity 0.5s ease-out";
    let endX= dir*(window.innerWidth*1.5);
    elem.style.transform=`translateX(${endX}px)`;
    elem.style.opacity="0";
    setTimeout(()=>{
      if(elem.parentNode) elem.parentNode.removeChild(elem);
      renderCards();
    },500);
  }
  function resetCardStyle(elem){
    elem.style.transition="transform 0.2s ease-out, opacity 0.2s ease-out";
    elem.style.transform="translateX(0) translateY(0)";
    elem.style.opacity="1";
  }
}

/***********************
 * INFO OVERLAY
 ***********************/
infoOverlay.addEventListener("click", closeInfoOverlay);

function showInfoOverlay(rItem){
  let rid= rItem.basic_information.id;
  if(detailsCache[rid]){
    fillInfoOverlay(rItem, detailsCache[rid]);
    openInfoOverlay();
  } else {
    let url= "https://api.discogs.com/releases/"+ rid;
    fetch(url,{
      headers:{
        "User-Agent":"DiscogsHalfScalePartialAdjust/1.0",
        "Authorization":"Discogs token="+ DISCOGS_TOKEN
      }
    })
    .then(resp=>{
      if(!resp.ok) throw new Error("Overlay fetch error "+ resp.status);
      return resp.json();
    })
    .then(data=>{
      detailsCache[rid]= data;
      fillInfoOverlay(rItem, data);
      openInfoOverlay();
    })
    .catch(err=>{
      console.error("Overlay fetch err:", err);
      infoContent.innerHTML="<p>Error loading details</p>";
      openInfoOverlay();
    });
  }
}
function fillInfoOverlay(rItem, releaseData){
  infoContent.innerHTML="";

  let h2= document.createElement("h2");
  h2.textContent= rItem.basic_information.title;
  infoContent.appendChild(h2);

  let artStr= rItem.basic_information.artists.map(a=>a.name).join(", ");
  let h3= document.createElement("h3");
  h3.textContent= artStr;
  h3.style.color="#ccc";
  infoContent.appendChild(h3);

  // --- Create the Spotify Player Container ---
  const spotifyContainer = document.createElement("div");
  // Style the container to be nearly full-width and centered.
  spotifyContainer.style.width = "90%";
  spotifyContainer.style.margin = "0 auto 20px";  // 20px bottom margin for spacing
  spotifyContainer.style.textAlign = "center";
  
  // Add the container at the very top of the info overlay.
  infoContent.appendChild(spotifyContainer);
  
  // Use the scrubbed artist name and album title.
  // (Since you already scrub the artist names after fetching, this uses the cleaned-up name.)
  const albumTitle = rItem.basic_information.title;
  const artistName = rItem.basic_information.artists[0]?.name || "";
  
  // Embed the Spotify player in the container.
  embedSpotifyPlayerInContainer(spotifyContainer, artistName, albumTitle);

  if(releaseData.labels){
    let labelStr= releaseData.labels.map(l=>l.name).join(", ");
    if(labelStr) addInfoRow("Label:", labelStr);
  }

  if(releaseData.year) addInfoRow("Year:", String(releaseData.year));
  if(releaseData.country) addInfoRow("Country:", releaseData.country);
  if(releaseData.genres) addInfoRow("Genre(s):", releaseData.genres.join(", "));
  if(releaseData.styles) addInfoRow("Style(s):", releaseData.styles.join(", "));
  if(releaseData.notes) addInfoRow("Notes:", releaseData.notes);
}
function addInfoRow(label, val){
  let lbl= document.createElement("div");
  lbl.className="extra-label";
  lbl.textContent= label;
  let v= document.createElement("div");
  v.className="extra-value";
  v.textContent= val;
  infoContent.appendChild(lbl);
  infoContent.appendChild(v);
}
function openInfoOverlay(){
  infoOverlay.classList.add("visible");
  infoOverlay.style.display = "block";
  document.documentElement.style.overflow = "hidden";
  document.body.style.overflow = "hidden";
  // Prevent interaction with the card underneath
  cardStack.style.pointerEvents = "none";
}

function closeInfoOverlay(){
  // Find and remove the Spotify iframe if it exists.
  const spotifyIframe = infoContent.querySelector("iframe");
  if (spotifyIframe) {
    spotifyIframe.parentNode.removeChild(spotifyIframe);
  }
  infoOverlay.classList.remove("visible");
  setTimeout(()=>{
    if(!infoOverlay.classList.contains("visible")){
      infoOverlay.style.display = "none";
      document.documentElement.style.overflow = "";
      document.body.style.overflow = "";
      // Re-enable card interactions
      cardStack.style.pointerEvents = "auto";
    }
  }, 300);
}
</script>
</body>
</html>
